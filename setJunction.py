# !/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import xml.dom.minidom
import numpy as np
import seaborn
import matplotlib.pyplot as plt
import pyproj
import sys
import copy


def findAllPath(dir_name):
    print("******Finding files ******")
    for maindir, subdir, file_list_str in os.walk(dir_name):
        file_list = []
        for each in file_list_str:
            try:
                file_number = int(each[:-4])
                file_list.append(file_number)
            except:
                print('Ignore <%s>' % each)

        filepath_list = []
        for each in sorted(file_list):
            filename = str(each) + '.xml'
            filepath = os.path.join(maindir, filename)
            filepath_list.append(filepath)

    print("Dir <%s> has %d XML files." % (maindir, len(filepath_list)))

    return filepath_list


def parseXML(filepath, count, MAX):
    print("******Parsing <%s>******" % filepath)
    points = []
    DOMTree = xml.dom.minidom.parse(filepath)
    collection = DOMTree.documentElement
    if collection.getElementsByTagName('node'):
        nodes = collection.getElementsByTagName('node')

        for node in nodes:
            lon = node.getAttribute("lon")
            lat = node.getAttribute("lat")
            point_id = node.getAttribute("id")
            point = [float(lon), float(lat), int(point_id)]
            point[0], point[1] = pyproj.transform(p1, p2, point[0], point[1])
            points.append(point)

    else:
        print("Empty file, no node.")

    if collection.getElementsByTagName('way'):
        ways = collection.getElementsByTagName('way')

        if len(ways) == 1:
            for way in ways:
                way_id = int(way.getAttribute('id'))
        else:
            print("Error: mutiple way_id.")
    else:
        print("Error: no elements <way>.")

    if not len(points):
        count += 1

    way_id -= count * MAX
    for each in points:
        each[2] -= count * MAX

    return points, way_id, count


def setIntersection(points, points_stack, way_id, DIS_DELTA):
    print('******Setting junction point. Way id: %d******' % way_id)

    shape = points_stack.shape
    if points:
        if not shape[0]:
            points_stack = np.vstack([points[0], points[-1]])
            print('First way, set two junction points')
        else:
            points_stack, point = stackPoint(
                points[0], points_stack, DIS_DELTA, index_str='First point')
            points[0] = point
            points_stack, point = stackPoint(
                points[-1], points_stack, DIS_DELTA, index_str='Last point')
            points[-1] = point

    else:
        print('no points.')

    # print(points_stack.shape)
    return points, points_stack


def calcDis(point, points_stack):
    lon_delta = np.subtract(point[0], points_stack[:, 0])
    lat_delta = np.subtract(point[1], points_stack[:, 1])
    dis = np.sqrt(np.multiply(lon_delta, lon_delta) + np.multiply(lat_delta, lat_delta))
    dis = dis[:, np.newaxis]

    return np.hstack([points_stack, dis])


def stackPoint(point, points_stack, DIS_DELTA, index_str=''):
    points_stack_dis = calcDis(point, points_stack)
    # print(points_stack_dis)
    point_stack_dis_min = points_stack_dis.min(axis=0)
    # print(point_stack_dis_min)
    index = np.argwhere(points_stack_dis == point_stack_dis_min[-1])
    row = index[0][0]
    col = index[0][1]
    # print(row, col)

    if abs(point_stack_dis_min[-1]) < DIS_DELTA:
        point_lon = points_stack_dis[row, 0]
        point_lat = points_stack_dis[row, 1]
        point_id = points_stack_dis[row, col - 1]
        print('%s already exits in junction points, point id: %d.' % (index_str, point_id))
        point = [point_lon, point_lat, point_id]

    else:
        points_stack = np.vstack([points_stack, point])
        print('%s stacked.' % index_str)

    return points_stack, point


def writeXML(points, way_id, NODE_ATTR):
    print('******Writing XML******')

    doc = xml.dom.minidom.Document()
    doc.appendChild(doc.createComment("Generated by python, Author: Mengze."))
    osmNode = doc.createElement("osm")
    doc.appendChild(osmNode)

    addNode(doc, osmNode, points, NODE_ATTR)
    addWay(doc, osmNode, points, way_id)

    file_name = '%s/%d.xml' % (DIR_OUT, way_id)
    print(file_name)

    with open(file_name, 'w') as f:
        doc.writexml(f, addindent="    ", newl="\n", encoding="UTF-8")


def addNode(doc, osmNode, points, NODE_ATTR):
    count = 0
    for point in points:
        point[0], point[1] = pyproj.transform(p2, p1, point[0], point[1])
        count += 1
        lon = '%.8f' % point[0]
        lat = '%.8f' % point[1]
        point_id = '%d' % point[2]
        pointNode = doc.createElement("node")
        pointNode.setAttribute('id', point_id)
        pointNode.setAttribute('lat', lat)
        pointNode.setAttribute('lon', lon)

        if (count == 1) | (count == len(points)):
            pointNode.setAttribute('type', NODE_ATTR['type'][3])
            point_tagNode = doc.createElement("tag")
            point_tagNode.setAttribute('k', "highway")
            point_tagNode.setAttribute('v', "traffic_signals")
            pointNode.appendChild(point_tagNode)
        else:
            pointNode.setAttribute('type', NODE_ATTR['type'][-1])

        osmNode.appendChild(pointNode)


def addWay(doc, osmNode, points, way_id):
    way_id_str = '%d' % way_id
    wayNode = doc.createElement("way")
    wayNode.setAttribute('id', way_id_str)
    osmNode.appendChild(wayNode)

    for point in points:
        point[0], point[1] = pyproj.transform(p2, p1, point[0], point[1])
        point_id = '%d' % point[2]
        ndtNode = doc.createElement("nd")
        ndtNode.setAttribute('ref', point_id)
        wayNode.appendChild(ndtNode)

    way_tagNode = doc.createElement("tag")
    way_tagNode.setAttribute('k', "name:en")
    way_tagNode.setAttribute('v', "double way")

    wayNode.appendChild(way_tagNode)


def showInspect(points_stack, all_seg, points_all, PAUSE):

    for junction_point in points_stack:
        relevant_seg = np.empty(shape=[0, 3])

        for seg in all_seg:
            seg = np.array(seg)
            first = junction_point[2] == seg[0][2]
            last = junction_point[2] == seg[-1][2]

            if first | last:
                relevant_seg = np.vstack([relevant_seg, seg])

        range_PCS = calcRange(relevant_seg)

        set_xylim(range_PCS)
        plt.pause(PAUSE)
        plt.scatter(relevant_seg[:, 0], relevant_seg[:, 1], c='g', marker='o')
        plt.scatter(points_stack[:, 0], points_stack[:, 1], c='k', marker='o')
        plt.pause(PAUSE * 2)
        plt.clf()
        # plt.axis('equal')
        set_xylim(range_PCS)
        plt.scatter(points_all[:, 0], points_all[:, 1], c='r', marker='o')
        plt.scatter(points_stack[:, 0], points_stack[:, 1], c='k', marker='o')
        plt.pause(PAUSE * 2)


def set_xylim(range_PCS):
    range_xscale = range_PCS[1] - range_PCS[0]
    range_xmid = (range_PCS[1] + range_PCS[0]) / 2
    range_yscale = (range_PCS[3] - range_PCS[2])
    range_ymid = (range_PCS[3] + range_PCS[2]) / 2

    if range_xscale >= range_yscale:
        plt.xlim((range_xmid - range_xscale * 2, range_xmid + range_xscale * 2))
        plt.ylim((range_ymid - range_xscale, range_ymid + range_xscale))
    else:

        plt.ylim((range_ymid - range_yscale, range_ymid + range_yscale))
        plt.xlim((range_xmid - range_yscale * 2, range_xmid + range_yscale * 2))


def showAnimate(points_stack, points_all, PAUSE, range_PCS):
    set_xylim(range_PCS)
    plt.pause(PAUSE)
    plt.scatter(points_stack[:, 0], points_stack[:, 1], c='k', marker='o')
    # plt.axis("equal")
    plt.pause(PAUSE)

    plt.clf()

    set_xylim(range_PCS)
    plt.scatter(points_all[:, 0], points_all[:, 1], c='r', marker='o')
    plt.scatter(points_stack[:, 0], points_stack[:, 1], c='k', marker='o')
    # plt.axis("equal")
    plt.pause(PAUSE)


def checkEnv(DIR_IN, DIR_OUT):
    if not os.path.isdir(DIR_IN):
        print('DIR <%s> not exists.' % DIR_IN)
        sys.exit()

    if OUTPUT:
        if not os.path.isdir(DIR_OUT):
            print('Making dir <%s>.' % DIR_OUT)
            os.mkdir(DIR_OUT)
        else:
            print('Dir <%s> exists, removing old and making new empty DIR.' % DIR_OUT)
            cmd = "rm -rf %s" % DIR_OUT
            os.system(cmd)
            os.mkdir(DIR_OUT)


def saveData(points_all, points_stack):
    '''
    lat lon
    '''
    points_all[:, 0], points_all[:, 1] = pyproj.transform(
        p2, p1, points_all[:, 0], points_all[:, 1])
    points_stack[:, 0], points_stack[:, 1] = pyproj.transform(
        p2, p1, points_stack[:, 0], points_stack[:, 1])
    np.savetxt(SAVE_TXT_POINTS, points_all)
    np.savetxt(SAVE_TXT_JUNCTIONS, points_stack)


def calcRange(points):
    points_arr = np.array(points)
    lon_max = points_arr[:, 0].max()
    lon_min = points_arr[:, 0].min()
    lat_max = points_arr[:, 1].max()
    lat_min = points_arr[:, 1].min()
    range_PCS = [lon_min, lon_max, lat_min, lat_max]

    return range_PCS


def main():
    checkEnv(DIR_IN, DIR_OUT)

    filepath_in = findAllPath(DIR_IN)

    all_seg = []
    points_all = np.empty(shape=[0, 3])
    points_stack = np.empty(shape=[0, 3])
    count_empty_file = 0
    for each in filepath_in:
        points_each_file = []
        points_each_file, way_id, count_empty_file = parseXML(each, count_empty_file, MAX)
        points_each_file, points_stack = setIntersection(
            points_each_file, points_stack, way_id, DIS_DELTA)

        if len(points_each_file):
            range_PCS = calcRange(points_each_file)

            points_all = np.vstack([points_all, points_each_file])
            all_seg.append(copy.deepcopy(points_each_file))
            if OUTPUT:
                writeXML(points_each_file, way_id, NODE_ATTR)

            if INSPECT:
                mng = plt.get_current_fig_manager()
                # mng.window.showMaximized()
                mng.resize(1600, 800)
                showAnimate(points_stack, points_all, PAUSE, range_PCS)

    if INSPECT:
        plt.clf()
        plt.scatter(points_all[:, 0], points_all[:, 1], c='r', marker='o')
        plt.scatter(points_stack[:, 0], points_stack[:, 1], c='k', marker='o')
        plt.axis("equal")
        plt.pause(2)

    print('Done! Set %d junction points.' % points_stack.shape[0])

    if INSPECT:
        print('Inspecting ...')
        showInspect(points_stack, all_seg, points_all, PAUSE)
        plt.clf()
        plt.scatter(points_all[:, 0], points_all[:, 1], c='r', marker='o')
        plt.scatter(points_stack[:, 0], points_stack[:, 1], c='k', marker='o')
        plt.axis("equal")
        plt.pause(2)
        print('Inspect Display over.')

    plt.show()

    if OUTPUT:
        saveData(points_all, points_stack)
        print('Data <%s> and <%s> have saved.' % (SAVE_TXT_POINTS, SAVE_TXT_JUNCTIONS))


if __name__ == '__main__':
    print(sys.version)
    DIR_IN = '/home/mengze/Desktop/GPS_test_Aug18'
    DIR_OUT = '/home/mengze/Desktop/GPS__test_Aug18_out02'
    SAVE_TXT_POINTS = '/home/mengze/Desktop/GPS__test_Aug05_points02.txt'
    SAVE_TXT_JUNCTIONS = '/home/mengze/Desktop/GPS_test_Aug05_junctions02.txt'
    # [vel] 4.2m/s 8.4m/s
    # [type] 0:"start_point" 1:"end_point"; 2:"way_point"; 3:"fork_point";
    #        4:"search_in"; 5:"search_out"; 6:"cruise_start"; 7:"cruise_end"
    NODE_ATTR = {'vel': ['4.2', '8.4'], 'type': ['0', '1', '2', '3', '4', '5', '6', '7', '-1']}

    p1 = pyproj.Proj(init="epsg:4326")
    p2 = pyproj.Proj(init="epsg:3857")
    MAX = 10000
    DIS_DELTA = 20
    OUTPUT = False
    INSPECT = True
    PAUSE = 0.05
    seaborn.set()

    main()
